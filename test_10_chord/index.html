<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chord Trainer</title>
<style>
body {
  font-family: sans-serif;
  text-align: center;
  background: #f0f0f0;
}
h1 { margin-top: 20px; }
button { margin: 5px; padding: 5px 10px; font-size: 16px; }
#status { font-size: 18px; margin-top: 15px; }
#keyboardContainer { display: flex; justify-content: center; margin-top: 20px; overflow-x: auto; padding: 10px; }
.keyboard { position: relative; display: inline-block; user-select: none; height: 200px; }
.white-key {
  width: 8vw; max-width: 40px; height: 180px; background: white; border: 1px solid #000; display: inline-block;
  vertical-align: bottom; position: relative; cursor: pointer; box-sizing: border-box; margin: 0; text-align: center;
  font-size: 12px; line-height: 180px;
}
.white-key.active { background: #d0f0d0; }
.white-key.mic-detect { background: red; }
.black-key {
  width: 5vw; max-width: 25px; height: 120px; background: black; position: absolute; top: 0; z-index: 2;
  cursor: pointer; border-radius: 0 0 3px 3px;
}
.black-key.active { background: #444; }
.black-key.mic-detect { background: red; }
#controls { margin-top: 20px; }
#chordSelection { margin-top: 10px; }
</style>
</head>
<body>

<h1>Chord Trainer ðŸŽ¶</h1>

<div id="controls">
  <button id="startBtn">Start/Restart Game</button>
  <button id="replayBtn" disabled>Replay Chord</button>
  <button id="nextBtn" disabled>Next Chord</button>
  <button id="submitBtn" disabled>Submit Answer</button>
  <button id="resetSelectionBtn" disabled>Reset Selected Notes</button>
  <label><input type="checkbox" id="arpeggioMode"> Arpeggio Mode</label>
</div>

<div id="chordSelection">
  <label><input type="checkbox" class="category" value="power" checked> Power (2 notes)</label>
  <label><input type="checkbox" class="category" value="major" checked> Major (3 notes)</label>
  <label><input type="checkbox" class="category" value="minor" checked> Minor (3 notes)</label>
</div>

<p id="status">Press "Start/Restart Game" to begin!</p>
<p id="selectedNotes">Selected Notes: </p>

<div id="keyboardContainer">
  <div class="keyboard" id="keyboard"></div>
</div>

<script>
// ---------------- SETTINGS ----------------
const octaves = [3,4];
const semitones = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
let notes = [];
octaves.forEach(o => semitones.forEach(s => notes.push(s+o)));

const noteFrequencies = {};
notes.forEach(n => {
  const octave = parseInt(n.replace(/\D/g,''));
  const semitoneOffsets = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
  noteFrequencies[n] = 16.35 * Math.pow(2, octave + semitoneOffsets[n.replace(/\d/,'')] / 12);
});

let currentChord = null;
let round = 0;
let score = 0;
let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let acceptingPitch = false;
let selectedNotes = [];
let maxRounds = 10;
const minNote = 'C3';
const maxNote = 'B4';

// ---------------- AUDIO ----------------
function playNote(note, duration=0.5){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain).connect(audioCtx.destination);
  osc.frequency.value = noteFrequencies[note];
  gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
  osc.start();
  osc.stop(audioCtx.currentTime+duration);
}

// ---------------- KEYBOARD ----------------
const keyboardDiv = document.getElementById('keyboard');
let keyElements = {};

function createKeyboard(){
  keyboardDiv.innerHTML='';
  keyElements = {};
  const displayNotes = notes.slice(notes.indexOf(minNote), notes.indexOf(maxNote)+1);

  // create white keys
  let whiteKeys = displayNotes.filter(n=>!n.includes('#'));
  whiteKeys.forEach(n=>{
    const key = document.createElement('div');
    key.className='white-key';
    key.dataset.note=n;
    key.textContent=n;
    key.addEventListener('click',()=>{ 
      playNote(n);
      if(acceptingPitch && !selectedNotes.includes(n)){
        selectedNotes.push(n);
        updateSelectedNotes();
      }
    });
    keyboardDiv.appendChild(key);
    keyElements[n]=key;
  });

  // create black keys
  displayNotes.forEach((n,i)=>{
    if(n.includes('#')){
      const prevWhite = displayNotes.slice(0,i).reverse().find(nn=>!nn.includes('#'));
      if(prevWhite){
        const key = document.createElement('div');
        key.className='black-key';
        key.dataset.note=n;
        const left = keyElements[prevWhite].offsetLeft + keyElements[prevWhite].offsetWidth * 0.7;
        key.style.left = left+'px';
        key.addEventListener('click',()=>{ 
          playNote(n);
          if(acceptingPitch && !selectedNotes.includes(n)){
            selectedNotes.push(n);
            updateSelectedNotes();
          }
        });
        keyboardDiv.appendChild(key);
        keyElements[n]=key;
      }
    }
  });
}
createKeyboard();

function updateSelectedNotes(){
  const sorted = selectedNotes.slice().sort((a,b)=>notes.indexOf(a)-notes.indexOf(b));
  document.getElementById('selectedNotes').textContent = 'Selected Notes: ' + sorted.join(', ');
}

// ---------------- CHORDS ----------------
const chordPatterns = {
  power: [[0,7]],
  major: [[0,4,7]],
  minor: [[0,3,7]]
};

function isChordInRange(chordNotes){
  return chordNotes.every(n => notes.indexOf(n)>=notes.indexOf(minNote) && notes.indexOf(n)<=notes.indexOf(maxNote));
}

function generateChord(){
  const categories = Array.from(document.querySelectorAll('.category:checked')).map(c=>c.value);
  if(categories.length===0) return null;

  let chord = null;
  let attempt=0;
  while(!chord && attempt<100){
    attempt++;
    const category = categories[Math.floor(Math.random()*categories.length)];
    const rootNotes = notes.slice(notes.indexOf(minNote), notes.indexOf(maxNote)+1);
    const root = rootNotes[Math.floor(Math.random()*rootNotes.length)];
    const intervals = chordPatterns[category][0];
    const chordNotes = intervals.map(i=> notes[notes.indexOf(root)+i]).filter(Boolean);
    if(chordNotes.length===intervals.length && isChordInRange(chordNotes)){
      chord = {root, category, notes: chordNotes};
    }
  }
  return chord;
}

// ---------------- GAME LOGIC ----------------
const startBtn = document.getElementById('startBtn');
const replayBtn = document.getElementById('replayBtn');
const nextBtn = document.getElementById('nextBtn');
const submitBtn = document.getElementById('submitBtn');
const resetSelectionBtn = document.getElementById('resetSelectionBtn');
const arpeggioCheckbox = document.getElementById('arpeggioMode');

startBtn.addEventListener('click', startGame);
replayBtn.addEventListener('click', replayChord);
nextBtn.addEventListener('click', nextChord);
submitBtn.addEventListener('click', submitAnswer);
resetSelectionBtn.addEventListener('click', ()=>{
  selectedNotes = [];
  updateSelectedNotes();
});

function startGame(){
  round=0; score=0;
  document.getElementById('status').textContent="Listen and identify the chord!";
  nextChord();
}

function playChord(chord){
  acceptingPitch=false;
  selectedNotes=[];
  updateSelectedNotes();
  const duration = 0.5;
  if(arpeggioCheckbox.checked){
    chord.notes.forEach((n,i)=>{
      setTimeout(()=>playNote(n,duration), i*duration*1000);
    });
    setTimeout(()=>acceptingPitch=true, chord.notes.length*duration*1000);
  } else {
    chord.notes.forEach(n=>playNote(n,duration));
    setTimeout(()=>acceptingPitch=true, duration*1000);
  }
}

function replayChord(){
  if(currentChord) playChord(currentChord);
}

function nextChord(){
  if(round>=maxRounds){
    document.getElementById('status').textContent=`âœ… Game over! Score: ${score}/${maxRounds}`;
    replayBtn.disabled=true; nextBtn.disabled=true; submitBtn.disabled=true; resetSelectionBtn.disabled=true;
    return;
  }
  round++;
  currentChord = generateChord();
  document.getElementById('status').textContent=`Round ${round}: Listen...`;
  replayBtn.disabled=false; submitBtn.disabled=false; resetSelectionBtn.disabled=false; nextBtn.disabled=true;
  playChord(currentChord);
}

function submitAnswer(){
  if(!currentChord) return;
  const sortedCorrect = currentChord.notes.slice().sort((a,b)=>notes.indexOf(a)-notes.indexOf(b));
  const sortedUser = selectedNotes.slice().sort((a,b)=>notes.indexOf(a)-notes.indexOf(b));
  let correct = sortedCorrect.join(', ');
  let user = sortedUser.join(', ');
  let message;
  if(sortedCorrect.join()===sortedUser.join()){
    score++;
    message=`âœ… Correct! ${currentChord.category} chord (${currentChord.root}): ${correct} (${score}/${round})`;
  } else {
    message=`âŒ Wrong! Correct ${currentChord.category} chord (${currentChord.root}): ${correct}. Your answer: ${user} (${score}/${round})`;
  }
  document.getElementById('status').textContent=message;
  acceptingPitch=false;
  submitBtn.disabled=true;
  nextBtn.disabled=false;
}

// ---------------- MICROPHONE PITCH DETECTION ----------------
let analyser, dataArray, source, pitchBuffer=[];
const HOLD_FRAMES = 30; // ~0.5s

navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
  source = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize=2048;
  source.connect(analyser);
  dataArray = new Float32Array(analyser.fftSize);
  detectPitch();
});

function autoCorrelate(buffer, sampleRate){
  let SIZE = buffer.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++) rms += buffer[i]*buffer[i];
  rms = Math.sqrt(rms/SIZE);
  if(rms<0.01) return -1;
  let r=[];
  for(let i=0;i<SIZE;i++) r[i]=0;
  for(let lag=0;lag<SIZE;lag++){
    for(let i=0;i<SIZE-lag;i++) r[lag]+=buffer[i]*buffer[i+lag];
  }
  let d=0; while(r[d]>r[d+1]) d++;
  let maxval=-1,maxpos=-1;
  for(let i=d;i<SIZE;i++){
    if(r[i]>maxval){ maxval=r[i]; maxpos=i; }
  }
  let T0=maxpos;
  return sampleRate/T0;
}

function detectPitch(){
  analyser.getFloatTimeDomainData(dataArray);
  const pitch = autoCorrelate(dataArray,audioCtx.sampleRate);
  Object.values(keyElements).forEach(k=>k.classList.remove('mic-detect'));

  if(pitch>0 && acceptingPitch){
    let closestNote=null, minDiff=Infinity;
    for(let n in noteFrequencies){
      if(notes.indexOf(n)>=notes.indexOf(minNote) && notes.indexOf(n)<=notes.indexOf(maxNote)){
        const diff=Math.abs(noteFrequencies[n]-pitch);
        if(diff<minDiff){ minDiff=diff; closestNote=n; }
      }
    }
    if(closestNote){
      keyElements[closestNote].classList.add('mic-detect');
      pitchBuffer.push(closestNote);
      if(pitchBuffer.length>HOLD_FRAMES) pitchBuffer.shift();
      const lastNote = pitchBuffer[pitchBuffer.length-1];
      const allSame = pitchBuffer.every(n=>n===lastNote);
      if(allSame && pitchBuffer.length>=HOLD_FRAMES){
        if(!selectedNotes.includes(lastNote)){
          selectedNotes.push(lastNote);
          updateSelectedNotes();
        }
        pitchBuffer=[];
      }
    } else pitchBuffer=[];
  } else pitchBuffer=[];
  requestAnimationFrame(detectPitch);
}
</script>

</body>
</html>
