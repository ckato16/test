<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Piano Roll Trainer ðŸŽ¹</title>
<style>
body { font-family: sans-serif; background: #fff; text-align: center; margin: 0; padding: 0; overflow-x: hidden; }

#pianoWrapper {
  width: 100%;
  margin-top: 20px;
  overflow-x: visible;
  overflow-y: visible;
}

.scale-container {
  width: 100%;
  display: block;
  transform-origin: top left;
}

canvas {
  background: #fafafa;
  display: block;
  border:1px solid #aaa;
}

#keyboard {
  position: relative;
  width: 1750px;
  height: 200px;
  user-select: none;
}

.white-key {
  width: 40px;
  height: 200px;
  background: white;
  border:1px solid #000;
  position: absolute;
  cursor: pointer;
}
.white-key.active {
  background: red;
}

.black-key {
  width: 30px;
  height: 120px;
  background: black;
  position: absolute;
  top:0;
  z-index:2;
  cursor:pointer;
}
.black-key.active {
  background: red;
}

#scoreDisplay {
  margin-top: 10px;
}

button, input { margin:5px; }
</style>
</head>
<body>

<h2>MIDI Piano Roll Trainer ðŸŽµ</h2>
<input type="file" id="midiFile" accept=".mid,.midi"/><br>
<button id="loadSample">Load sample</button><br>

<label>BPM: <input type="number" id="bpm" value="120" min="30" max="240"></label><br>

<button id="startBtn">Start</button>
<button id="stopBtn">Stop</button>
<button id="resetBtn">Reset</button>

<br>

<!-- ðŸŽšï¸ SEEK SLIDER -->
<label>
  Position:
  <input type="range" id="seekSlider" min="0" max="1" step="0.0001" value="0" style="width:400px;">
</label>
<span id="timeLabel">0.00s</span>

<div id="scoreDisplay">Score: 0%</div>

<div id="pianoWrapper">
  <div id="scaleContainer" class="scale-container">
    <canvas id="pianoRoll" height="400"></canvas>
    <div id="keyboard"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.40/build/Tone.min.js"></script>

<script>
const canvas = document.getElementById('pianoRoll');
const ctx = canvas.getContext('2d');

const keyboardDiv = document.getElementById('keyboard');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');
const bpmInput = document.getElementById('bpm');

const seekSlider = document.getElementById("seekSlider");
const timeLabel = document.getElementById("timeLabel");

const startMidiNote = 24;
const endMidiNote = 96;

const whiteKeyWidth = 40;
const blackKeyWidth = 30;

let midiNotes = [];
let activeNotes = {};
let startTime = null;
let running = false;

let totalNotes = 0;
let hitNotes = 0;

let totalSongTime = 0;
let manualOffset = 0;
let useManualSeek = false;

let synth = new Tone.Synth().toDestination();

/* SCORE DISPLAY */
function updateScore() {
  const score = totalNotes ? (hitNotes / totalNotes) * 100 : 0;
  document.getElementById("scoreDisplay").innerText =
    "Score: " + score.toFixed(1) + "%";
}

/* ================
      KEYBOARD
================ */
const keys = [];
let whiteIndex = 0;

for (let i=startMidiNote; i<=endMidiNote; i++) {
  const noteName = Tone.Frequency(i,"midi").toNote();
  const isBlack = noteName.includes('#');
  let key;

  if (!isBlack) {
    key = document.createElement('div');
    key.className = 'white-key';
    key.style.left = (whiteIndex * whiteKeyWidth) + 'px';

    const label = document.createElement("div");
    label.style.position = "absolute";
    label.style.bottom = "5px";
    label.style.width = "100%";
    label.style.textAlign = "center";
    label.style.fontSize = "14px";
    label.style.pointerEvents = "none";
    label.innerText = noteName;
    key.appendChild(label);
    whiteIndex++;
  } else {
    key = document.createElement('div');
    key.className = 'black-key';
    key.style.left = (whiteIndex * whiteKeyWidth - blackKeyWidth/2) + 'px';
  }

  key.dataset.note = i;
  key.onmousedown = ()=> playSound(i, true);
  key.onmouseup = ()=> playSound(i, false);

  keyboardDiv.appendChild(key);
  keys.push({note:i, element:key, isBlack});
}

function getKeyX(note){
  const key = keys.find(k=>k.note===note);
  return key ? parseFloat(key.element.style.left) : 0;
}

// piano roll width
const numWhiteKeys = keys.filter(k => !k.isBlack).length;
canvas.width = numWhiteKeys * whiteKeyWidth;

/* ======================
       SOUND + SCORING
====================== */
function playSound(note, pressed){
  const key = keys.find(k => k.note === note)?.element;
  if (pressed) {
    synth.triggerAttack(Tone.Frequency(note,"midi"));
    activeNotes[note] = performance.now();
    if (key) key.classList.add("active");

    const targetLine = canvas.height - 10;
    for (let n of midiNotes) {
      if (n.hit) continue;
      if (n.noteNumber === note) {
        const speed = getFallSpeed();
        const noteHeight = n.duration * speed;
        const y = (currentTime() - n.time) * speed - noteHeight;
        if (y + noteHeight >= targetLine && y <= targetLine) {
          n.hit = true;
          hitNotes++;
          updateScore();
          break;
        }
      }
    }
  } else {
    synth.triggerRelease();
    delete activeNotes[note];
    if (key) key.classList.remove("active");
  }
}

/* ======================
   MIDI LOAD HANDLING
====================== */
document.getElementById('midiFile').addEventListener('change', async e=>{
  const file = e.target.files[0];
  if (!file) return;

  const arrayBuffer = await file.arrayBuffer();
  const midi = new Midi(arrayBuffer);

  midiNotes = [];
  midi.tracks.forEach(track=>{
    track.notes.forEach(n=>{
      midiNotes.push({
        noteNumber:n.midi,
        time:n.time,
        duration:n.duration
      });
    });
  });

  midiNotes.sort((a,b)=>a.time-b.time);

  totalSongTime = computeSongEnd();

  totalNotes = midiNotes.length;
  hitNotes = 0;
  midiNotes.forEach(n => n.hit = false);
  updateScore();

  seekSlider.value = 0;
  manualOffset = 0;

  alert("âœ… MIDI loaded! Click Start to play.");
});

/* SAMPLE LOADER */
document.getElementById("loadSample").onclick = () => {
  const q = 0.5;
  const notes = [60,61,62,63,64,65,66,67];

  midiNotes = [];
  let t = 0;

  notes.forEach(n=>{
    midiNotes.push({ noteNumber:n, time:t, duration:q });
    t += q;
  });

  totalSongTime = computeSongEnd();

  totalNotes = midiNotes.length;
  hitNotes = 0;
  midiNotes.forEach(n => n.hit = false);
  updateScore();

  seekSlider.value = 0;
  manualOffset = 0;

  alert("ðŸŽµ Sample loaded! Press Start.");
};

function computeSongEnd() {
  const speed = getFallSpeed();
  const canvasHeight = canvas.height;

  // Compute the time when each note fully leaves the screen
  let maxTime = 0;

  midiNotes.forEach(n => {
    const fallComplete = n.time + n.duration + (canvasHeight / speed);
    if (fallComplete > maxTime) maxTime = fallComplete;
  });

  return maxTime;
}

/* ======================
        CONTROLS
====================== */
startBtn.onclick = ()=>{
  if (!midiNotes.length) return alert("Load MIDI or sample first!");
  startTime = performance.now() - manualOffset * 1000;
  running = true;
  useManualSeek = false;
};

stopBtn.onclick = ()=> running = false;

resetBtn.onclick = () => {
  // Stop playback
  running = false;

  // Reset score
  hitNotes = 0;
  midiNotes.forEach(n => n.hit = false);
  updateScore();

  // Reset position
  manualOffset = 0;
  seekSlider.value = 0;
  timeLabel.textContent = "0.00s";

  // Force a redraw at time = 0
  useManualSeek = true;
  draw();   // force visual update
  useManualSeek = false;
};


function currentTime() {
  let t;

  if (!running) {
    // When stopped or slider is active â†’ show manualOffset
    t = manualOffset;
  } else if (useManualSeek) {
    // First frame after sliding
    t = manualOffset;
  } else {
    // Normal playback
    t = (performance.now() - startTime) / 1000;
  }

  // Clamp to song length
  if (totalSongTime > 0)
    t = Math.min(t, totalSongTime);

  return t;
}

function getFallSpeed(){
  return 150 * (parseFloat(bpmInput.value) / 120);
}

/* ======================
      SEEK SLIDER
====================== */
seekSlider.oninput = () => {
  if (!totalSongTime) return;

  useManualSeek = true;
  manualOffset = parseFloat(seekSlider.value) * totalSongTime;
  timeLabel.textContent = manualOffset.toFixed(2) + "s";
};

seekSlider.onchange = () => {
  startTime = performance.now() - manualOffset * 1000;
  useManualSeek = false;
};

/* ======================
      DRAW LOOP
====================== */
function getKeyWidth(note) {
  const key = keys.find(k => k.note === note);
  return key ? (key.isBlack ? blackKeyWidth : whiteKeyWidth) : 20;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const now = currentTime();
  if (running && now >= totalSongTime) {
    running = false;
    manualOffset = totalSongTime;
    seekSlider.value = 1;
    timeLabel.textContent = totalSongTime.toFixed(2) + "s";
  }
  const speed = getFallSpeed();
  const targetLine = canvas.height - 10;

  if (midiNotes.length > 0) {
    for (let n of midiNotes) {
      const x = getKeyX(n.noteNumber);
      const width = getKeyWidth(n.noteNumber);
      const h = n.duration * speed;
      const y = (now - n.time) * speed - h;

      if (y < targetLine) {
        ctx.fillStyle = n.hit ? "green" : "red";
        ctx.fillRect(x, y, width, h);
      }
    }
  }

  // Update slider while playing
  if (running && totalSongTime > 0 && !useManualSeek) {
    const t = currentTime();
    seekSlider.value = Math.min(1, t / totalSongTime);
    timeLabel.textContent = t.toFixed(2) + "s";
  }

  requestAnimationFrame(draw);
}
draw();

/* ======================
   RESPONSIVE SCALING
====================== */
function resizeScale() {
  const baseWidth = 1750;
  const screenWidth = window.innerWidth;

  const scale = screenWidth / baseWidth;

  const scaleContainer = document.getElementById("scaleContainer");
  scaleContainer.style.transform = `scale(${scale})`;
  scaleContainer.style.width = baseWidth + "px";
}

window.addEventListener("resize", resizeScale);
resizeScale();
</script>

</body>
</html>
